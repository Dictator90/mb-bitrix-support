## Продвинутые возможности Storage

Помимо базовых обёрток над ORM (`Entity`, `EntityObject`, `Collection`, `Query`) пакет содержит дополнительные утилиты для работы с хранилищем:

- query‑helper `MB\Bitrix\Storage\Query` (расширенный where*/with* уже описан в разделе `storage-and-highloadblock.md`);
- трейт‑миксины и контракты для описания индексов и дополнительных условий (см. `src/Storage/Concerns` и `src/Contracts/Storage`);
- утилиты `QueryHelper`, `SqlHelper` (см. исходники пакета).

В этом разделе кратко описаны идеи и сценарии использования этих компонентов.

---

## Расширенный Query‑builder (напоминание)

Файл: `src/Storage/Query.php`

Основная задача `MB\Bitrix\Storage\Query` — предоставить **fluent‑интерфейс** для построения сложных фильтров:

- `where*` / `having*` вызываются либо:
  - на статических методах `DataManager` (например, `whereAny`, `whereAll`, `withRelation` и т.п.);
  - либо на внутреннем `Filter` (`Bitrix\Main\ORM\Query\Filter\ConditionTree`).

Если метод начинается с `where` и:

- существует в `DataManager` — он вызывается, первым аргументом передаётся текущий `Query`;
- существует в `Filter` — фильтр применяется к текущему запросу;
- иначе — кидается `SystemException` с подробным сообщением.

То же правило распространяется на методы `with*` (но только через `DataManager`).

Это позволяет переносить повторяющиеся фильтры и связи в `DataManager`, сохраняя компактный и читаемый код вызова.

---

## Трейты и контракты для индексов и дополнительных условий

В пространстве имён `MB\Bitrix\Storage\Concerns` и `MB\Bitrix\Contracts\Storage` предусмотрены строительные блоки для:

- декларативного описания индексов и их автоматического создания;
- задания дополнительных условий (`WHERE`) для типичных запросов.

Ключевые элементы (смотри исходники в репозитории):

- трейт `BuildIndexes` — описывает метод/логику построения индексов для сущности;
- трейт `DeleteByFilter` — добавляет удобный метод для удаления записей по фильтру;
- контракты:
  - `ShouldBeIndexes` — сущность, которая должна уметь сообщить о своих индексах;
  - `ShouldBeAdditionalWhere` — сущность, которая определяет дополнительные условия отбора.

Типовой сценарий:

- ваш `DataManager` реализует один или несколько контрактов;
- в нём подключён соответствующий трейт;
- существующие миграции/менеджеры (или специальный «индексный» менеджер) вызывают методы трейта для:
  - построения/обновления индексов;
  - применения дополнительных условий в запросах.

Пример (условный, структура смотрите в исходниках):

```php
use MB\Bitrix\Storage\Concerns\BuildIndexes;
use MB\Bitrix\Contracts\Storage\ShouldBeIndexes;

class MyStorageTable extends DataManager implements ShouldBeIndexes
{
    use BuildIndexes;

    public static function getIndexes(): array
    {
        return [
            // массивы описаний индексов в формате Bitrix ORM
        ];
    }
}
```

Миграция/менеджер может вызвать:

```php
MyStorageTable::buildIndexes(); // условный метод из трейта, см. реализацию
```

---

## Утилиты `QueryHelper` и `SqlHelper`

В `src/Storage` есть дополнительные служебные классы:

- `QueryHelper` — набор статических методов для:
  - типичных преобразований фильтров;
  - подготовки сложных запросов (например, для пагинации, агрегаций и т.п.);
- `SqlHelper` — утилиты для:
  - работы с сырым SQL, генерации фрагментов условий, экранирования и пр.

Точные методы и их сигнатуры зависят от версии пакета (см. исходники), но общая идея:

- предоставить **единый слой** для сложной логики, не размазывая её по десяткам различных `DataManager` и мест вызова;
- инкапсулировать особенности конкретной СУБД (MySQL, MariaDB, др.) и синтаксиса Bitrix ORM.

---

## Пример комбинированного использования

Предположим, у вас есть сущность `MyEntityTable`, которая:

- реализует `ShouldBeIndexes` и использует `BuildIndexes`;
- содержит статический метод `whereActive(Query $query)` для фильтрации по статусу;
- используется через `MB\Bitrix\Storage\Query`.

```php
use MB\Bitrix\Storage\Query;

$entity = MyEntityTable::getEntity(); // должен быть совместим с MB\Bitrix\Storage\Entity

$query = new Query($entity);

$rows = $query
    ->setSelect(['ID', 'NAME', 'STATUS'])
    ->whereActive()               // статический метод DataManager
    ->whereIn('ID', [1, 2, 3])    // метод Filter
    ->setOrder(['ID' => 'DESC'])
    ->fetchAll();
```

При необходимости миграция может:

```php
// где-то в процессе установки/обновления
MyEntityTable::buildIndexes(); // или аналогичный метод из трейта BuildIndexes
```

---

## Рекомендации

- Вынесите **повторяющиеся условия и связи** (`where*`, `with*`) в статические методы `DataManager` и вызывайте их через `MB\Bitrix\Storage\Query`.
- Используйте трейты из `Storage\Concerns` для:
  - централизованного описания индексов;
  - типичных CRUD‑операций по фильтру.
- В сложных запросах комбинируйте возможности:
  - ORM Bitrix;
  - `Storage\Query` (where*/with*);
  - вспомогательные методы `QueryHelper`/`SqlHelper`.

Это позволит удерживать логику работы с хранилищем в одном месте, упрощая сопровождение и оптимизацию запросов.

